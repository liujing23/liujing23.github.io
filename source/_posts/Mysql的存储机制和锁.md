---
title: Mysql的存储机制和锁
date: 2023-04-17 14:30:19
tags: [mysql, JAVA]
categories:
- [技术, JAVA]
---

#### 1.mysql的存储引擎

默认为InnoDB

还有**MyISAM存储引擎**



#### 2.InnoDB的特性

1）支持提交，回滚等事务

2）支持完整的外键约束

3）专为大数量设计

4）实现了行级锁，共享锁和排他锁



#### 3.MyISAM的特性

MyISAM拥有较高的插入、查询速度，但**不支持事物**和行级锁



#### 4.锁的分类

按锁粒度分：

​	行锁：锁某行数据，颗粒度最小，并发度高

​	表锁：锁整张表，颗粒度大，并发度低

​	间隙锁：锁一个区间



还可以分为：

​	共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写

​	排他锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写



还可以分为：

​	乐观锁：并不会真正锁某行记录，而是通过一个版本号来实现

​	悲观锁：行锁，表锁都是悲观锁



在事务的隔离级别实现中，需要用锁来解决幻读



#### 4.事务

##### 1）并发带来的问题

- **脏读：**一个事务读取另一个**未提交**的数据。
- **不可重复读：**一个事务范围内两个相同的查询却返回了不同数据。
- **幻读：**一个事务范围内两个相同的查询却返回了不同数据。对应的是插入操作。

**数据库通常会通过锁机制来解决数据并发访问问题，直接使用锁非常麻烦，为此**数据库为用户提供了自动锁机制，用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁

##### 2）事务的隔离级别

从上到下，由低到高

- Read Uncommited，读未提交，即一个事务可以读取另一个未提交事务的数据；并发操作会导致脏读
- Read Commited，读操作，即一个事务要等到另一个事务提交后才能读取数据；解决脏读问题；并发操作会导致不可重复读
- Repeatable Read，重复读，即开始读取数据（事务开启）时，不再允许修改操作；解决不可重复读问题；并发操作会导致幻读（对应insert操作）
- Serializable，序列化，最高的事务隔离级别，该级别下，事务串行化顺序执行；避免脏读、不可重复读与幻读；但是该级别效率低下，比较消耗数据库性能，一般不用。

![事务的隔离级别](https://raw.githubusercontent.com/liujing23/FigureBed/main/blog/img/20240223145953.png)









