---
title: 线程死锁的解决方案
date: 2023-02-23 09:38:28
tags: [多线程, JAVA]
categories:
- [技术, JAVA]
---

# 一.问题

Process.waitFor导致死锁

# 二.产生原因

使用Runtime.exec执行命令时，JAVA的线程会创建一个子进程，用于执行命令，而且子进程和JAVA线程会分别独立运行。主线程需要等待脚本进程，即子进程的返回结果和日志信息，在JAVA线程中调用Process.waitFor挂起来等待子进程完成。

子进程执行时，不断的打印日志信息，我们通过Process.getInputStream和 Process.getErrorStream进行获取正常输出日志和错误日志进行处理。

这个时候子进程不断的向JAVA线程写入数据，而JAVA线程调用Process.waitFor后已经阻塞挂起，而子进程在不断的向JAVA线程进行写入数据，当我们的Process.getInputStream的buffer缓冲区被写满，而JAVA线程依然挂起并未消费buffer中的数据，导致子进程无法继续向buffer缓冲区中继续写入数据，导致子进程也挂起。 

JAVA线程和子进程都处于挂起的状态，JAVA线程等待子进程的结束，子进程等待JAVA线程对buffer缓冲区中的数据进行消费。两者在相互等待导致死锁。

综上：由于缓存区的日志信息无法消费，导致线程相互等待，从而发生死锁

# 三.解决方案

创建线程池，每次使用一个线程处理缓存区的日志

``

```text
private static ThreadPoolExecutor executor;
 
static {
    ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
            .setNameFormat("cmd-pool-%d").build();
    //根据实际情况创建线程池
    executor = new ThreadPoolExecutor(6, 10, 5,
            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(1024),
            namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());
}
 
/**
 * 流处理
 * @param stream
 */
private static void clearStream(InputStream stream) {
    //处理buffer的线程
    executor.execute(new Runnable() {
        @Override
        public void run() {
 
            String line = null;
 
            try (BufferedReader in = new BufferedReader(new InputStreamReader(stream));) {
                while ((line = in.readLine()) != null) {
                    LoggerUtils.debug(CmdExecUtils.class,line);
                }
            } catch (IOException e) {
                LoggerUtils.error(CmdExecUtils.class,"exec error : {}", e);
            }
        }
    });
}
 
public static boolean execCommond(String... args) {
    boolean flg = true;
    Runtime run = Runtime.getRuntime();
    try {
        Process p;
        if (args != null && args.length == 1) {
            p = run.exec(args[0]);
        } else {
            p = run.exec(args);
        }
 
        InputStream stream=p.getInputStream();
        LoggerUtils.info(CmdExecUtils.class, stream + "....getInputStream..");
 
        //消费正常日志
        clearStream(stream);
        //消费错误日志
        clearStream(p.getErrorStream());
 
        if (p.waitFor() != 0) {
            if (p.exitValue() == 1) {
                LoggerUtils.info(CmdExecUtils.class,"=============exec=====================命令执行失败!");
                flg = false;
            }
        }
 
    } catch (Exception e) {
        e.printStackTrace();
        flg = false;
    }
    return flg;
}
```

# 四.线程池的实现原理

提交一个任务到线程池中，线程池的处理流程如下： 

![线程池的处理流程](https://raw.githubusercontent.com/liujing23/FigureBed/main/blog/img/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpeg)

1）判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 

2）线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 

3）判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。



# 五.线程池的使用

## 1.线程池的创建

查看源码，线程池有七个参数

![线程池参数](https://raw.githubusercontent.com/liujing23/FigureBed/main/blog/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0.png)

##### 1）corePoolSize 线程池核心线程大小

线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。

##### 2）maximumPoolSize 线程池最大线程数量

当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。

##### 3）keepAliveTime 空闲线程存活时间

一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定

##### 4）unit 空闲线程存活时间单位

keepAliveTime的计量单位

##### 5）workQueue 工作队列

新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：

①ArrayBlockingQueue

基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。

②LinkedBlockingQuene

基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。

③SynchronousQuene

一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

④PriorityBlockingQueue

具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

##### 6）threadFactory 线程工厂

创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等

##### 7）handler 拒绝策略

当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：

①CallerRunsPolicy

该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。

②AbortPolicy

该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

③DiscardPolicy

该策略下，直接丢弃任务，什么都不做。

④DiscardOldestPolicy

该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列

## 2.向线程池提交任务

可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。

execute()方法用于提交不需要返回值的任务，所以无法判断任务被线程池执行成功。

submit方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完成。

## 3、关闭线程池

可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。

它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以**无法响应中断的任务可能永远无法终止**。但是它们存在一定的区别，shutdownNow首先将线程池状态设置成STOP，然后尝试停止所有的正在执行或暂停任务线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。

只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪种方法来关闭线程池，应该由线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法（通俗的理解，shutdownNow是强制关闭，返回为未执行任务列表；而shutdown会等待当前任务执行完毕才真正关闭）。

## 4、合理地配置线程池

要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。

- 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。
- 任务的优先级：高、中和低。
- 任务的执行时间：长、中和短。
- 任务的依赖性：是否依赖其他系统资源，如数据库连接。

性质不同的任务可以用不同规模的线程池分开处理。CPU密集性任务应配置尽可能小的线程，如配置N(cpu) + 1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2 × N(cpu)。混合型任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差不是很大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获取当前设备的CPU个数。

优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。他可以让优先级高的任务先执行。

执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。

依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲的时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。

**建议使用有界队列**。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。

## 5、线程池的监控

如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。

- taskCount：线程池需要执行的任务数量。
- completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。
- largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。
- getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个值只增不减。
- getActiveCount：获取活动的线程数。

通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里都是空方法。
